create schema if not exists "_supavisor";


drop policy "Users can update own profile." on "public"."profiles";

alter table "public"."user_roles" drop constraint "public_user_roles_role_id_fkey";

drop function if exists "public"."handle_new_user_test"();

alter table "public"."roles" drop constraint "roles_pkey";

alter table "public"."user_roles" drop constraint "user_roles_pkey";

drop index if exists "public"."roles_pkey";

drop index if exists "public"."user_roles_pkey";

alter table "public"."roles" drop column "description";

alter table "public"."roles" drop column "role_id";

alter table "public"."roles" drop column "role_name";

alter table "public"."roles" add column "id" bigint generated by default as identity not null;

alter table "public"."roles" add column "name" text not null;

alter table "public"."roles" add column "slug" text not null;

alter table "public"."user_roles" drop column "role_id";

alter table "public"."user_roles" add column "role" text default 'user'::text;

CREATE UNIQUE INDEX roles_name_key ON public.roles USING btree (name);

CREATE UNIQUE INDEX roles_slug_key ON public.roles USING btree (slug);

CREATE UNIQUE INDEX roles_pkey ON public.roles USING btree (id);

CREATE UNIQUE INDEX user_roles_pkey ON public.user_roles USING btree (user_id);

alter table "public"."roles" add constraint "roles_pkey" PRIMARY KEY using index "roles_pkey";

alter table "public"."user_roles" add constraint "user_roles_pkey" PRIMARY KEY using index "user_roles_pkey";

alter table "public"."roles" add constraint "roles_name_key" UNIQUE using index "roles_name_key";

alter table "public"."roles" add constraint "roles_slug_key" UNIQUE using index "roles_slug_key";

alter table "public"."user_roles" add constraint "public_user_roles_role_fkey" FOREIGN KEY (role) REFERENCES roles(slug) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."user_roles" validate constraint "public_user_roles_role_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.assign_role_to_new_users()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$begin
  insert into public.user_roles (user_id)
  values (new.id);
  return new;
end;$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$begin
  insert into public.profiles (id, email)
  values (new.id, new.email)
  on conflict (id)
  do update set
    email = excluded.email;
  return new;
end;$function$
;

create policy "Users can update own profile."
on "public"."profiles"
as permissive
for update
to authenticated
using ((id = auth.uid()))
with check ((id = auth.uid()));


CREATE TRIGGER trigger_new_user AFTER INSERT ON public.profiles FOR EACH ROW EXECUTE FUNCTION assign_role_to_new_users();


